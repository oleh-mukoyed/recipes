/* tslint:disable */
/* eslint-disable */
/**
 * Recipes API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddDishDto
 */
export interface AddDishDto {
    /**
     * 
     * @type {number}
     * @memberof AddDishDto
     */
    'userId': number;
    /**
     * 
     * @type {string}
     * @memberof AddDishDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AddDishDto
     */
    'notes'?: string;
    /**
     * 
     * @type {Array<AddIngredientDto>}
     * @memberof AddDishDto
     */
    'ingredients': Array<AddIngredientDto>;
}
/**
 * 
 * @export
 * @interface AddIngredientDto
 */
export interface AddIngredientDto {
    /**
     * 
     * @type {string}
     * @memberof AddIngredientDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AddIngredientDto
     */
    'number': string;
    /**
     * 
     * @type {number}
     * @memberof AddIngredientDto
     */
    'measurementId': number;
}
/**
 * 
 * @export
 * @interface AddUserDto
 */
export interface AddUserDto {
    /**
     * 
     * @type {string}
     * @memberof AddUserDto
     */
    'telegramId': string;
    /**
     * 
     * @type {string}
     * @memberof AddUserDto
     */
    'info'?: string;
}
/**
 * 
 * @export
 * @interface DishControllerGetDishes200Response
 */
export interface DishControllerGetDishes200Response {
    /**
     * 
     * @type {boolean}
     * @memberof DishControllerGetDishes200Response
     */
    'isArray': boolean;
    /**
     * 
     * @type {string}
     * @memberof DishControllerGetDishes200Response
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof DishControllerGetDishes200Response
     */
    'duration': string;
    /**
     * 
     * @type {string}
     * @memberof DishControllerGetDishes200Response
     */
    'method': string;
    /**
     * 
     * @type {DishPresenter}
     * @memberof DishControllerGetDishes200Response
     */
    'data'?: DishPresenter;
}
/**
 * 
 * @export
 * @interface DishPresenter
 */
export interface DishPresenter {
    /**
     * 
     * @type {number}
     * @memberof DishPresenter
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof DishPresenter
     */
    'sort': number;
    /**
     * 
     * @type {string}
     * @memberof DishPresenter
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DishPresenter
     */
    'notes'?: string;
    /**
     * 
     * @type {number}
     * @memberof DishPresenter
     */
    'userId': number;
    /**
     * 
     * @type {Array<IngredientPresenter>}
     * @memberof DishPresenter
     */
    'ingredients': Array<IngredientPresenter>;
}
/**
 * 
 * @export
 * @interface IngredientPresenter
 */
export interface IngredientPresenter {
    /**
     * 
     * @type {number}
     * @memberof IngredientPresenter
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof IngredientPresenter
     */
    'sort': number;
    /**
     * 
     * @type {string}
     * @memberof IngredientPresenter
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof IngredientPresenter
     */
    'number': string;
    /**
     * 
     * @type {MeasurementPresenter}
     * @memberof IngredientPresenter
     */
    'measurement': MeasurementPresenter;
}
/**
 * 
 * @export
 * @interface MeasurementChildPresenter
 */
export interface MeasurementChildPresenter {
    /**
     * 
     * @type {number}
     * @memberof MeasurementChildPresenter
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof MeasurementChildPresenter
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MeasurementChildPresenter
     */
    'shortName': string;
    /**
     * 
     * @type {number}
     * @memberof MeasurementChildPresenter
     */
    'childMultiplier'?: number;
}
/**
 * 
 * @export
 * @interface MeasurementControllerGetMeasurements200Response
 */
export interface MeasurementControllerGetMeasurements200Response {
    /**
     * 
     * @type {boolean}
     * @memberof MeasurementControllerGetMeasurements200Response
     */
    'isArray': boolean;
    /**
     * 
     * @type {string}
     * @memberof MeasurementControllerGetMeasurements200Response
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof MeasurementControllerGetMeasurements200Response
     */
    'duration': string;
    /**
     * 
     * @type {string}
     * @memberof MeasurementControllerGetMeasurements200Response
     */
    'method': string;
    /**
     * 
     * @type {MeasurementPresenter}
     * @memberof MeasurementControllerGetMeasurements200Response
     */
    'data'?: MeasurementPresenter;
}
/**
 * 
 * @export
 * @interface MeasurementPresenter
 */
export interface MeasurementPresenter {
    /**
     * 
     * @type {number}
     * @memberof MeasurementPresenter
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof MeasurementPresenter
     */
    'sort': number;
    /**
     * 
     * @type {string}
     * @memberof MeasurementPresenter
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MeasurementPresenter
     */
    'shortName': string;
    /**
     * 
     * @type {number}
     * @memberof MeasurementPresenter
     */
    'childMultiplier'?: number;
    /**
     * 
     * @type {MeasurementChildPresenter}
     * @memberof MeasurementPresenter
     */
    'child'?: MeasurementChildPresenter;
    /**
     * 
     * @type {MeasurementChildPresenter}
     * @memberof MeasurementPresenter
     */
    'parent'?: MeasurementChildPresenter;
}
/**
 * 
 * @export
 * @interface ResponseFormat
 */
export interface ResponseFormat {
    /**
     * 
     * @type {boolean}
     * @memberof ResponseFormat
     */
    'isArray': boolean;
    /**
     * 
     * @type {string}
     * @memberof ResponseFormat
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseFormat
     */
    'duration': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseFormat
     */
    'method': string;
}
/**
 * 
 * @export
 * @interface UpdateDishDto
 */
export interface UpdateDishDto {
    /**
     * 
     * @type {number}
     * @memberof UpdateDishDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UpdateDishDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDishDto
     */
    'notes'?: string;
    /**
     * 
     * @type {Array<UpdateIngredientDto>}
     * @memberof UpdateDishDto
     */
    'ingredients': Array<UpdateIngredientDto>;
}
/**
 * 
 * @export
 * @interface UpdateIngredientDto
 */
export interface UpdateIngredientDto {
    /**
     * 
     * @type {number}
     * @memberof UpdateIngredientDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UpdateIngredientDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateIngredientDto
     */
    'number': string;
    /**
     * 
     * @type {number}
     * @memberof UpdateIngredientDto
     */
    'measurementId': number;
}
/**
 * 
 * @export
 * @interface UserControllerGetUserByTelegramId200Response
 */
export interface UserControllerGetUserByTelegramId200Response {
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerGetUserByTelegramId200Response
     */
    'isArray': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserControllerGetUserByTelegramId200Response
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerGetUserByTelegramId200Response
     */
    'duration': string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerGetUserByTelegramId200Response
     */
    'method': string;
    /**
     * 
     * @type {UserPresenter}
     * @memberof UserControllerGetUserByTelegramId200Response
     */
    'data'?: UserPresenter;
}
/**
 * 
 * @export
 * @interface UserPresenter
 */
export interface UserPresenter {
    /**
     * 
     * @type {number}
     * @memberof UserPresenter
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof UserPresenter
     */
    'sort': number;
    /**
     * 
     * @type {boolean}
     * @memberof UserPresenter
     */
    'active': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserPresenter
     */
    'telegramId': string;
    /**
     * 
     * @type {string}
     * @memberof UserPresenter
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserPresenter
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserPresenter
     */
    'info'?: string;
}

/**
 * DishApi - axios parameter creator
 * @export
 */
export const DishApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddDishDto} addDishDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dishControllerAddDish: async (addDishDto: AddDishDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addDishDto' is not null or undefined
            assertParamExists('dishControllerAddDish', 'addDishDto', addDishDto)
            const localVarPath = `/api_v1/dish/dish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addDishDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dishControllerDeleteDish: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dishControllerDeleteDish', 'id', id)
            const localVarPath = `/api_v1/dish/dish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {number} userId 
         * @param {string} locale 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dishControllerGetDish: async (id: number, userId: number, locale: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dishControllerGetDish', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('dishControllerGetDish', 'userId', userId)
            // verify required parameter 'locale' is not null or undefined
            assertParamExists('dishControllerGetDish', 'locale', locale)
            const localVarPath = `/api_v1/dish/dish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dishControllerGetDishes: async (userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('dishControllerGetDishes', 'userId', userId)
            const localVarPath = `/api_v1/dish/dishes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateDishDto} updateDishDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dishControllerUpdateDish: async (updateDishDto: UpdateDishDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateDishDto' is not null or undefined
            assertParamExists('dishControllerUpdateDish', 'updateDishDto', updateDishDto)
            const localVarPath = `/api_v1/dish/dish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDishDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DishApi - functional programming interface
 * @export
 */
export const DishApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DishApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddDishDto} addDishDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dishControllerAddDish(addDishDto: AddDishDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DishControllerGetDishes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dishControllerAddDish(addDishDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dishControllerDeleteDish(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DishControllerGetDishes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dishControllerDeleteDish(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {number} userId 
         * @param {string} locale 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dishControllerGetDish(id: number, userId: number, locale: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DishControllerGetDishes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dishControllerGetDish(id, userId, locale, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dishControllerGetDishes(userId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DishControllerGetDishes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dishControllerGetDishes(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpdateDishDto} updateDishDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dishControllerUpdateDish(updateDishDto: UpdateDishDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DishControllerGetDishes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dishControllerUpdateDish(updateDishDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DishApi - factory interface
 * @export
 */
export const DishApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DishApiFp(configuration)
    return {
        /**
         * 
         * @param {DishApiDishControllerAddDishRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dishControllerAddDish(requestParameters: DishApiDishControllerAddDishRequest, options?: AxiosRequestConfig): AxiosPromise<DishControllerGetDishes200Response> {
            return localVarFp.dishControllerAddDish(requestParameters.addDishDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DishApiDishControllerDeleteDishRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dishControllerDeleteDish(requestParameters: DishApiDishControllerDeleteDishRequest, options?: AxiosRequestConfig): AxiosPromise<DishControllerGetDishes200Response> {
            return localVarFp.dishControllerDeleteDish(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DishApiDishControllerGetDishRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dishControllerGetDish(requestParameters: DishApiDishControllerGetDishRequest, options?: AxiosRequestConfig): AxiosPromise<DishControllerGetDishes200Response> {
            return localVarFp.dishControllerGetDish(requestParameters.id, requestParameters.userId, requestParameters.locale, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DishApiDishControllerGetDishesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dishControllerGetDishes(requestParameters: DishApiDishControllerGetDishesRequest, options?: AxiosRequestConfig): AxiosPromise<DishControllerGetDishes200Response> {
            return localVarFp.dishControllerGetDishes(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DishApiDishControllerUpdateDishRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dishControllerUpdateDish(requestParameters: DishApiDishControllerUpdateDishRequest, options?: AxiosRequestConfig): AxiosPromise<DishControllerGetDishes200Response> {
            return localVarFp.dishControllerUpdateDish(requestParameters.updateDishDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for dishControllerAddDish operation in DishApi.
 * @export
 * @interface DishApiDishControllerAddDishRequest
 */
export interface DishApiDishControllerAddDishRequest {
    /**
     * 
     * @type {AddDishDto}
     * @memberof DishApiDishControllerAddDish
     */
    readonly addDishDto: AddDishDto
}

/**
 * Request parameters for dishControllerDeleteDish operation in DishApi.
 * @export
 * @interface DishApiDishControllerDeleteDishRequest
 */
export interface DishApiDishControllerDeleteDishRequest {
    /**
     * 
     * @type {number}
     * @memberof DishApiDishControllerDeleteDish
     */
    readonly id: number
}

/**
 * Request parameters for dishControllerGetDish operation in DishApi.
 * @export
 * @interface DishApiDishControllerGetDishRequest
 */
export interface DishApiDishControllerGetDishRequest {
    /**
     * 
     * @type {number}
     * @memberof DishApiDishControllerGetDish
     */
    readonly id: number

    /**
     * 
     * @type {number}
     * @memberof DishApiDishControllerGetDish
     */
    readonly userId: number

    /**
     * 
     * @type {string}
     * @memberof DishApiDishControllerGetDish
     */
    readonly locale: string
}

/**
 * Request parameters for dishControllerGetDishes operation in DishApi.
 * @export
 * @interface DishApiDishControllerGetDishesRequest
 */
export interface DishApiDishControllerGetDishesRequest {
    /**
     * 
     * @type {number}
     * @memberof DishApiDishControllerGetDishes
     */
    readonly userId: number
}

/**
 * Request parameters for dishControllerUpdateDish operation in DishApi.
 * @export
 * @interface DishApiDishControllerUpdateDishRequest
 */
export interface DishApiDishControllerUpdateDishRequest {
    /**
     * 
     * @type {UpdateDishDto}
     * @memberof DishApiDishControllerUpdateDish
     */
    readonly updateDishDto: UpdateDishDto
}

/**
 * DishApi - object-oriented interface
 * @export
 * @class DishApi
 * @extends {BaseAPI}
 */
export class DishApi extends BaseAPI {
    /**
     * 
     * @param {DishApiDishControllerAddDishRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DishApi
     */
    public dishControllerAddDish(requestParameters: DishApiDishControllerAddDishRequest, options?: AxiosRequestConfig) {
        return DishApiFp(this.configuration).dishControllerAddDish(requestParameters.addDishDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DishApiDishControllerDeleteDishRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DishApi
     */
    public dishControllerDeleteDish(requestParameters: DishApiDishControllerDeleteDishRequest, options?: AxiosRequestConfig) {
        return DishApiFp(this.configuration).dishControllerDeleteDish(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DishApiDishControllerGetDishRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DishApi
     */
    public dishControllerGetDish(requestParameters: DishApiDishControllerGetDishRequest, options?: AxiosRequestConfig) {
        return DishApiFp(this.configuration).dishControllerGetDish(requestParameters.id, requestParameters.userId, requestParameters.locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DishApiDishControllerGetDishesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DishApi
     */
    public dishControllerGetDishes(requestParameters: DishApiDishControllerGetDishesRequest, options?: AxiosRequestConfig) {
        return DishApiFp(this.configuration).dishControllerGetDishes(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DishApiDishControllerUpdateDishRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DishApi
     */
    public dishControllerUpdateDish(requestParameters: DishApiDishControllerUpdateDishRequest, options?: AxiosRequestConfig) {
        return DishApiFp(this.configuration).dishControllerUpdateDish(requestParameters.updateDishDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MeasurementApi - axios parameter creator
 * @export
 */
export const MeasurementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} locale 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        measurementControllerGetMeasurements: async (locale: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locale' is not null or undefined
            assertParamExists('measurementControllerGetMeasurements', 'locale', locale)
            const localVarPath = `/api_v1/measurement/measurements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeasurementApi - functional programming interface
 * @export
 */
export const MeasurementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeasurementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} locale 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async measurementControllerGetMeasurements(locale: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeasurementControllerGetMeasurements200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.measurementControllerGetMeasurements(locale, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MeasurementApi - factory interface
 * @export
 */
export const MeasurementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeasurementApiFp(configuration)
    return {
        /**
         * 
         * @param {MeasurementApiMeasurementControllerGetMeasurementsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        measurementControllerGetMeasurements(requestParameters: MeasurementApiMeasurementControllerGetMeasurementsRequest, options?: AxiosRequestConfig): AxiosPromise<MeasurementControllerGetMeasurements200Response> {
            return localVarFp.measurementControllerGetMeasurements(requestParameters.locale, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for measurementControllerGetMeasurements operation in MeasurementApi.
 * @export
 * @interface MeasurementApiMeasurementControllerGetMeasurementsRequest
 */
export interface MeasurementApiMeasurementControllerGetMeasurementsRequest {
    /**
     * 
     * @type {string}
     * @memberof MeasurementApiMeasurementControllerGetMeasurements
     */
    readonly locale: string
}

/**
 * MeasurementApi - object-oriented interface
 * @export
 * @class MeasurementApi
 * @extends {BaseAPI}
 */
export class MeasurementApi extends BaseAPI {
    /**
     * 
     * @param {MeasurementApiMeasurementControllerGetMeasurementsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementApi
     */
    public measurementControllerGetMeasurements(requestParameters: MeasurementApiMeasurementControllerGetMeasurementsRequest, options?: AxiosRequestConfig) {
        return MeasurementApiFp(this.configuration).measurementControllerGetMeasurements(requestParameters.locale, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddUserDto} addUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerAddOrUpdateUser: async (addUserDto: AddUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addUserDto' is not null or undefined
            assertParamExists('userControllerAddOrUpdateUser', 'addUserDto', addUserDto)
            const localVarPath = `/api_v1/user/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} telegramId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetUserByTelegramId: async (telegramId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'telegramId' is not null or undefined
            assertParamExists('userControllerGetUserByTelegramId', 'telegramId', telegramId)
            const localVarPath = `/api_v1/user/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (telegramId !== undefined) {
                localVarQueryParameter['telegramId'] = telegramId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddUserDto} addUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerAddOrUpdateUser(addUserDto: AddUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerGetUserByTelegramId200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerAddOrUpdateUser(addUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} telegramId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGetUserByTelegramId(telegramId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerGetUserByTelegramId200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetUserByTelegramId(telegramId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {UserApiUserControllerAddOrUpdateUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerAddOrUpdateUser(requestParameters: UserApiUserControllerAddOrUpdateUserRequest, options?: AxiosRequestConfig): AxiosPromise<UserControllerGetUserByTelegramId200Response> {
            return localVarFp.userControllerAddOrUpdateUser(requestParameters.addUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserApiUserControllerGetUserByTelegramIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetUserByTelegramId(requestParameters: UserApiUserControllerGetUserByTelegramIdRequest, options?: AxiosRequestConfig): AxiosPromise<UserControllerGetUserByTelegramId200Response> {
            return localVarFp.userControllerGetUserByTelegramId(requestParameters.telegramId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for userControllerAddOrUpdateUser operation in UserApi.
 * @export
 * @interface UserApiUserControllerAddOrUpdateUserRequest
 */
export interface UserApiUserControllerAddOrUpdateUserRequest {
    /**
     * 
     * @type {AddUserDto}
     * @memberof UserApiUserControllerAddOrUpdateUser
     */
    readonly addUserDto: AddUserDto
}

/**
 * Request parameters for userControllerGetUserByTelegramId operation in UserApi.
 * @export
 * @interface UserApiUserControllerGetUserByTelegramIdRequest
 */
export interface UserApiUserControllerGetUserByTelegramIdRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiUserControllerGetUserByTelegramId
     */
    readonly telegramId: string
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {UserApiUserControllerAddOrUpdateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerAddOrUpdateUser(requestParameters: UserApiUserControllerAddOrUpdateUserRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerAddOrUpdateUser(requestParameters.addUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiUserControllerGetUserByTelegramIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerGetUserByTelegramId(requestParameters: UserApiUserControllerGetUserByTelegramIdRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerGetUserByTelegramId(requestParameters.telegramId, options).then((request) => request(this.axios, this.basePath));
    }
}



